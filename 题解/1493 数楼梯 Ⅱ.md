#### 题目描述

某楼梯有 *N* 阶，求从第 1 阶走到第 *N* 阶，共有多少种不同的走法。

规则：可以一步上一阶（一阶步），也可以一步上二阶（二阶步），但不允许任意连续的 3 步都是一阶步或二阶步。

#### 输入

一个正整数 N，表示楼梯的台阶数。

1≤*N*≤106

#### 输出

一行一个整数，表示结果。由于数值可能比较大，结果对 10^9^+7 取模。

#### 样例输入 复制

```plain
4
```

#### 样例输出 复制

```plain
2
```

---

---

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mxn = 1e6 + 6, mod = 1e9 + 7;
int n, ans;
//0,走；1,跳
int f[mxn][2];
int dp[mxn];
signed main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n;
	f[1][0] = f[2][0] = 1;
	f[3][0] = 1, f[3][1] = 1;
	f[4][0] = f[4][1] = 1;
	for (int i = 1; i <= n; ++i) {
		if (i >= 5) {
			//如果这个点是走过来的，那么他前两个点一定是跳的，
			//前一个也是跳的，因为前一个是走的情况包含在前两个是跳的里
			f[i][0] = (f[i - 2][1]+f[i-1][1]) % mod;
            //如果这个点是跳过来的，那么他前四个点一定是走的，
            //并且他前两个点是走的
            //不包含前两个点是跳的是因为该情况在上一句中包含了
			f[i][1] = (f[i - 4][0]+f[i-2][0]) % mod;
		}
		dp[i] = (f[i][0] + f[i][1]) % mod;
	}
	cout << dp[n] << '\n';
	return 0;
}
```



![img](http://172.20.8.83/upload/172.20.8.83/20230107/20230107152544_73219.png)