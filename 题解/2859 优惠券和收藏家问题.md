#### 题目描述

有 n 种类型的优惠券，每次购买可以随机获得一张优惠券。期望购买多少次可以集齐所有类型的优惠券。

#### 输入

一行一个整数 n

1≤n≤10^6^

#### 输出

一行一个整数，结果对 1e9+7 取模。

#### 样例输入 复制

```plain
样例1：
1

样例2：
2
```

#### 样例输出 复制

```plain
样例1：
1

样例2：
3
```





---

---



#### 涉及知识点

+ __快速幂__
+ __费马小定理__
+ __逆元__

#### 题目类型

+ __概率__
+ __期望__



###  知识点讲解



1. #### 快速幂

> **快速幂算法**（也称为**二分冪**）是一种用于高效计算大整数幂模运算的方法，它的时间复杂度是 O(log ⁡b)，相比于直接计算 a^b 再取模的方式（时间复杂度为 O(b)），快速幂能够大大加快计算速度，尤其在指数较大时更为显著。
>
> #### 快速幂算法的基本思想：
>
> 快速幂通过将指数 b 按照二进制分解的方式进行幂运算。每次只计算当前指数对应的部分幂，并通过不断平方的方式减少计算量。
>
> #### 数学原理：
>
> 我们可以将 a^b^ 分解为多次幂的乘积：
>
> - 如果 b 是偶数，那么 a^b^ = (a ^b/2^) ^2^；
>- 如果 b 是奇数，那么 a^b^ = a × a ^b−1^。
> 
>通过这个思想，可以把幂运算拆分成指数的二进制形式的组合，这样每次只需要计算一半的幂，逐步缩小问题规模。
> 
> #### 快速幂算法的步骤：
>
> 1. 初始化结果 res=1，并将底数 a 赋值给自身取模 p，即 a = a % p，以防止后续计算过程中出现溢出。
>
> 2. 循环进行，当 b>0 时：
>
>    - 如果当前 b 为奇数，那么将 res = (res × a) % p；
>   - 然后将底数 a 平方，并将 b 右移（即除以 2）。
> 
>3. 当 b=0 时，返回结果 res。
> 
>>#### 注意：
> >
> >快速幂算法通常使用 `long long`，因为快速幂会涉及大量幂运算和模运算，会远远超过 `int` 可表示的范围，导致溢出
>
> #### 例：
>
> ```cpp
>// 快速幂计算 a^b % p
> int mod_exp(int a, int b, int p) {
>   int result = 1;
>   a = a % p;
>  while (b > 0) {
>       if (b & 1) {
>          result = (result * a) % p;
>       }
>      a = (a * a) % p;
>       b >>= 1;
>   }
  return result;
  } 
  ```




2. #### 费马小定理

>**费马小定理**（Fermat's Little Theorem）是数论中的一个重要定理，特别在求解与模运算有关的问题时经常使用。它对于计算大整数的幂模运算，以及求解乘法逆元非常有用。
>
>####  费马小定理的内容：
>
>设 p 是一个**质数**，且 a 是一个**整数**，那么如果 a 不被 p 整除，即 gcd⁡(a,p)=1，则有：
>
>a^p−1^≡1 (mod p)
>
>换句话说，**a 的 p−1 次方对 p 取模等于 1**。
>
>#### 推论：
>
>根据这个定理，如果我们将等式两边都乘以 a^−1^（即 a 的乘法逆元），可以得到：
>
>**a^p−2^≡a^−1^ (mod p)**
>
>这就是说，**a 在模 p 意义下的乘法逆元等于 a^p−2^ (mod p)**。
>
>### 费马小定理的两个重要应用：
>
>1. **求大整数的幂模运算**。
>2. **求模 p 的乘法逆元**。
>
>### 总结：
>
>1. **费马小定理**可以帮助简化大指数的幂模运算。
>2. 它特别有用在求质数模数下的**乘法逆元**，通过计算 **a^p−2^mod  p** 来获得逆元。
>3. 配合**快速幂算法**，可以高效地计算出结果。
>
>### 费马小定理的背景
>
>在模一个质数 p 的运算中，费马小定理告诉我们，对于一个不为 p 整除的整数 a，有： a^p−1^≡1 (mod p)
>
>因此： a^p−2^≡a^−1^ (mod p)
>
>这意味着，我们可以通过计算 k^p−2^mod  p 来获得 k 的模 p 下的乘法逆元，用于执行除法操作。
>
>#### 运用：
>
>> **a^p-1^ ≡ 1 (mod p) **
>>
>> > **a^p-2^ ≡ a^-1^ (mod p)**
>> >
>> > ***a^-1^ ≡ a^p-2^ (mod p)***



3. #### 逆元

>**逆元**在数学中是一个关于数与乘法运算的概念。在模运算（即对一个数取模）中，如果一个数 a 存在一个数 b，使得：
>
>a × b ≡ 1 (mod m)
>
>那么我们称 b 是 a 在模 m 下的**乘法逆元**。这意味着 a 与 b 相乘后除以 m 余数为 1。换句话说，a 和 b 的乘积模 m 之后等于 1。 
>
>#### 逆元的存在条件：
>
>并不是所有数在模 m 下都有逆元。一个数 a 在模 m 下有乘法逆元的充要条件是：a 和 m 互质，也就是说 gcd(a,m)=1（即 a 和 m 的最大公约数为1）。
>
>#### 快速幂求逆元：
>
>为了高效计算逆元，通常会使用快速幂算法来求 a^m−2^ mod  m。快速幂算法的时间复杂度为 O(log m)，比直接计算 a^m−2^ 快得多。
>
>#### 例子（使用费马小定理）：
>
>假设我们要在模 10^9^+7 下求 3 的逆元。因为 10^9^+7 是质数，所以根据费马小定理：
>
>$3^{(10^9+7−2)}$ ≡ $3^{10^9+5}$ (mod10^9^+7)
>
>我们可以通过快速幂算法高效地求出这个值。
>
>#### 总结：
>
>- **逆元**是乘法运算中的“倒数”，它使得 a × b ≡ 1(mod m)。
>- 如果模数 m 是质数，可以使用费马小定理通过快速幂求解逆元。
>- 在其他情况下，可以使用扩展欧几里得算法来求解。





### 题目所求

**E= n/n + n/(n-1) + n/(n-2) + ······ + n/1 = n*(1/n + 1/(n+1) + ······ + 1/1)**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int md = 1e9 + 7;
int n;
int sum;

int ksm(int a, int b) {
	int result = 1;
	a %= md;
	while (b) {
		if (b & 1) {
			result = (result * a) % md;
		}
		a = (a * a) % md;
		b >>= 1;
	}
	return result;
}

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		sum = (sum + ksm(i, md - 2) ) % md;
	}
	sum = n * sum % md;
	cout << sum << '\n';
	return 0;
}
```

